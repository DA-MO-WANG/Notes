###### 锁-sychronized底层实现，各种锁的状态

​		[21.3 共享受限资源]()
​				多线程相比单线程好处，可以做更多事，在事的数量上表现有提升
​				但是引入了新的变数：新场景：多个实体--对--同一个资源，就会出现各种冲突。
​			

​				什么情况下容易发生并发问题？
​						多个线程的操作涉及同时操纵一个数据时
​						读写操作挨着，多线程下就容易出问题

​				怎么解决共享资源的竞争：
​						共享资源的本质：线程何时运行是不确定的--线程调度机制的本质是不确定性的
​						你的关键：保证两个任务在关键时刻，不会访问相同的资源

​						一种方式：加锁--序列化访问共享资源的方案
​						一种方式：副本方案
​								加锁的实现方案：
​										jdk 的 sychronized关键字

​										concurrent类库中的lock对象	
​										区分：
​												显式创建、锁定、释放
​												syschronize锁机制，当某些事物失败时就会抛出异常，但是没有机会对系统做清理工作——》lock机制，会在finally子句中做一些清理工作	
​												lock具有更细粒度控制力											









###### lock类

