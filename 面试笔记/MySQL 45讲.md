###### 第一篇

​		讲了一个针对学习mysql的学习理念：原理先行</br>
​		于此对比的是有充足经验和能力的人，时间的有效积累下还是被淘汰，这说明还不够。离开原理只是累积经验，成长速度还是不够快。而建立在原理基础上的经验才是加速器。</br>
​		理念：原理先行——》先找到最初的原理、原型——〉逐步演化，一直演化到最上层</br>

###### 第二篇

​		学习理念：看一个事，要先从高纬度理解，这样可以鸟瞰全貌（高纬度能看到大环境，而大环境决定语意）-对立的是：一开始就直接陷入细节，然后被淹死了

​		举例：平时在使用mysql，我们只需要知道，要根据什么，返回什么，其他没必要在最简单的用途还不明了的时候，就去掉进内部执行过程这个深渊--刚开始就是应该这么想，想多了反而走错了

​		一条查询语句在MySQL内部的执行过程：</br>
​				2个大世界-6个组件：5 + 1：server层(公用的)、存储引擎层(插件式)</br>
​				客户端小人和**连接器**小人的互动：</br>
​						要想利用mysql就得先搭上桥梁，建立联系---这个得找连接器</br>
​						明面上是要用户名-密码，暗地里要过一个权限认证逻辑；走过了，然后连接状态就产生了--空闲超时参数timeout</br>
​						链接有两种情况，长连接就是如果有持续请求，就会一直使用不变的连结；短连接就是执行完几次就断开连接
​						经验之谈：因为连接的创建成本高，所以推荐长连接——》带来一个问题：占用内存会越来越大，因为内存不释放，直到连接断开才释放，最终导致oom——〉常规解决思路：</br>
​								1.定期断开长连接，或者在执行完一个非常占用内存的大查询后</br>
​								2.mysql5.7之后提供了一个功能：mysql_reset connection 来重新初始化（类似回到出厂状态，而不是裸机状态）</br>
​			 与**查询缓存**小人互动</br>
​					这是开始执行查询的开始，（就像人做开发一样，接到一个任务，首先做的不是敲代码，而是先看看过去是不是做过类似的，有没有现成代码，直接可以ctrl+v/c），这里缓存以key-value形式存储，key存储的是sql语句，value存储的是查询结果，如果在缓存中命中，就直接返回结果</br>
​					查询缓存这个功能弊大于利，适合于静态表环境，比如系统配置表；mysql8.0已经放弃了这个功能</br>
​				与**分析器**小人互动</br>
​						找不到缓存，只能老老实实往下走。要想执行，mysql得先弄明白要干什么。先是词法分析，拆出每个词代表什么意思；然后是语法分析，符合不符合语法规定</br>
​				与**优化器**互动</br>
​						前面是知道要干什么了，接下来确定执行方案。其实mysql内部和我们人的想的那样唯一死板还不同，它并没有要求规定死了用什么顺序，而人为了唯一确定，自己添加了很多限制。比如有多个索引，选择用那个索引，这个没有死的规则，比如连接多张表，从哪个表入手，理论上都可以。但是要经过优化器的优化选择标准，最终确定一个方案
​				与**执行器**互动</br>
​						先判断对这个表有没有相应的权限</br>
​						打开表，利用引擎存储的接口，来读取表的第一行，满足条件存到结果集（先取再判断）</br>	
​						如果有索引，则取满足条件的第一行（这里不一样，提前先做判断了，直接取符合条件的）</br>				

​		mysql常识：</br>
​				具体的存储引擎不止一个，InnoDB(5.5后默认)、MyISAM、Memory-----建表时，用engine=？来指定

- -----------------------------------------------------------*-我的节奏：我每次状态时间在1/3一页，45*3=135，1h至少有一次沉浸，一天至少8次，大概15天一轮*

  ​     

  ###### 一条更新语句是如何执行的

  ​		更新语句除了走查询语句那一套，还多了东西：两个日志-redo重做日志/bin归档日志
  ​		redo日志，怎么理解？
  ​				作者这个赊账账本的例子很好。更新语句不是实时更新的，而是先把这个操作记录在一个临时位置上，在另一个时间再写入磁盘——》提高效率，在压力小的时候再执行写入操作
  ​				WAL技术，wtrite ahead logging  先写日志
  ​						先把记录写到redo日志里，更新内存---暂时完成了
  ​						等到系统空闲，引擎会把记录更新到磁盘
  ​				问题：日志是固定大小的，如果满了，那就先把一部分日志更新到磁盘，然后腾出日志空间记录
  ​							write pos-记录位置指针  与 check point-擦除位置指针 --crash safe 能力
  ​		binlog日志，怎么理解？
  ​				